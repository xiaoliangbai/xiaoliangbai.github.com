---
layout: post
title: 
date: '2016-11-27T16:16:00.003-08:00'
author: Xiaoliang Bai
tags:
- Neural Network
- Math
- Deep Learning
- Classifier
- Machine Learning
use_math: true
modified_time: '2016-11-27T22:23:50.679-08:00'
blogger_id: tag:blogger.com,1999:blog-622863892871609087.post-3425909253140039118
blogger_orig_url: http://xiaoliangbai.blogspot.com/2016/11/softmax-classifier-in-neural-network.html
---

<h2 style="text-align: center;">Softmax Classifier in Neural Network</h2><div><h3></h3><h3>Concept</h3><br />&nbsp; Softmax classifier, together with Support Vector Machine (SVM) are the two most common classifiers used in neural networks. They are usually the last later to convert input data or data from hidden layer to output score for potential classes.</div><div><br /></div><div>&nbsp; For both Softmax and SVM, the raw scores are calculated exactly the same way via linear transformation (a.k.a. matrix multiplication). Suppose we have input data X with 'T' test cases and each test case with feature dimension 'F', and the classifier is trying to map output to C classes. Then X.shape is (T, F). The classifiers uses a weight matrix W of (F, C) to convert X to raw scores Z, a vector with C elements. The raw score calculation function can be expressed as:<br /><br /></div><div>$Z(X,W) = X * W $<br /><br />or &nbsp; &nbsp; $Z = X.dot(W)$<br /><br />Softmax function is used to convert raw scores (Z) to a normalized probabilities (q):<br /><br />$q(z_i) = \frac{e^{z_i}}{\sum\limits_{k=1}^{C} e^{{ "{{" }}z_k}}}$<br /><br />and the subtotal of all q is 1.<br /><br />The Softmax classifier then uses a&nbsp;<a href="https://en.wikipedia.org/wiki/Cross_entropy">cross-entropy</a> loss, between real distribution (p) and the calculated distribution (q), as an objective function for optimization. For a given test case $X_i$, the loss:<br /><br />$L(p, q)_i = - \sum\limits_{k=1}^{C} p(z_k) * log(q(z_k)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\tag{1}$<br /><br />&nbsp; Softmax classifier will change the weight matrix W in order to reduce cross-entropy loss. Note that for supervised learning, the correct class distribution p(x) contains only one '1' (i.e. Y = [0, ..., 1, ..., 0]). Hence for each test case, only the one $q(x_k), k$ that corresponding to correct class ($k=y$) contributes to the final loss.<br /><br />&nbsp; For the rest of this blog, we will use $L$ instead of $L_i$ to stand for loss for a given test $X_i$ to simplify the problem. For all test cases, it is simply a sum of all the $L_i$ calculated.<br /><br /><h3>Engineering A Numerically Stable Softmax Function&nbsp;</h3><div><br />&nbsp; The cross-entropy loss can be expressed as a probability distribution. For input data $x_i$ with corresponding class $y_i$:<br /><br /></div><div>&nbsp;$q(y_i | x_i) = \frac{e^{z_{y_i}}}{\sum\limits_{j=1}^{C} e^{z_j}}$</div><div><br /></div><div>&nbsp; It looks simple enough to implement strictly. However, the exponential operator can produce a large number. Divide such a large number can be numerically unstable. We need a way to avoid numerical issues as much as possible.</div><div><br /></div><div>&nbsp; A nice property of exponential function is that for negative variable $ r &lt; 0$, the output $e^r$ is squashed between (0, 1]. The idea here is to transfer the numerator and denominator into negative domain without changing the value of the faction:<br /><br />&nbsp; &nbsp;$\frac{e^{z_{y_i}}}{\sum\limits_{j=1}^{C} &nbsp;e^{z_j}} = &nbsp; \frac{e^{z_{y_i} + M}}{ \sum\limits_{j=1}^{C}&nbsp;&nbsp;e^{{ "{{" }}z_j} +&nbsp;M}} $<br /><br />&nbsp; Constant M is just a number that we want to transfer $z$ into the non-positive domain $z-M$. We can use the largest score of $Z$ vector: $ M = -max(Z)$<br /><br /><h3>Gradient</h3><br />&nbsp; To guide optimization process, we need to calculate gradient of Loss function with regarding to $W_{i,j}$. Direct calculation is a daunting task because mapping from W to Loss goes through linear transformation, then Softmax function and then loss function. As usual, we use chain-rule to peel the onion.<br /><br />&nbsp; First, Softmax function gradient with regarding to raw score vector Z can be calculated per element wise:<br /><br />$\frac{\partial q(z_i)}{\partial z_{j}} = q(z_i)(1-q(z_i))$ when $i = j$ and<br />&nbsp;$\frac{\partial q(z_i)}{\partial z_{j}} = -q(z_i)q(z_j)$ when $i \neq j$<br /><br />&nbsp; 2nd, consider cross-entropy loss function (1). The grand truth distribution P has only one '1'. Suppose $Z_y$ is the one corresponding to correct answer. Then the loss function becomes:<br /><br />$\begin{align} \frac{\partial L(p, q)}{\partial z_j} = \frac{\partial L(p, q(z_y))}{\partial z_j} = q(z_j) - 1(y,j) &nbsp; &nbsp; &nbsp;\tag{2} \label{eq:2} \end{align}$ <br />&nbsp; &nbsp; in which $z_y$ is the one corresponding to the correct class for a given test case $X_i$.<br />And 1(y,j) is the&nbsp;<a href="https://en.wikipedia.org/wiki/Kronecker_delta">kronecker delta function</a>:<br /><br />$1(y,j) = \begin{cases} 1 &amp; y = j \\<br />&nbsp;0 &amp; y\neq j \end{cases} $<br /><br />This is how we calculate elements for the partial differential vector of (1, C):<br /><br />$\frac{\partial L}{\partial Z} = \left[ \frac{\partial L}{\partial z_1}, \frac{\partial L}{\partial z_2},<br />..., \frac{\partial L}{\partial z_C} \right] &nbsp; &nbsp; &nbsp; &nbsp;\tag{3}$<br /><br />&nbsp; As the 3rd step, we will handle the matrix multiplication: $W*X = Z$ of the fully connected layer. Let's check the matrix dimensions first. W.shape is (num_classes, num_features) or (C, F), X.shape is (num_features, 1) and raw score Z is (num_classes, 1).<br /><br />&nbsp; The goal of this optimization is to find better W to produce accurate Z outputs in each iteration. Hence W is the parameter matrix to be fine tuned. We need partial derivatives of Z with regarding to W. W itself is a (C, F) matrix, to make things easier to process, we flat W matrix into a row vector of length C*F, Wflat = W.reshape(1, C*F). Then the partial derivatives is a (C, CF) matrix, which matches with C outputs (Z) and C*F parameters of W (flat version):<br /><br />$ \frac{\partial Z}{\partial w_{i,j}} = \left[ &nbsp;\begin{array}{ccccc} \frac{\partial z_1}{\partial w_{1,1}} &amp; \frac{\partial z_1}{\partial w_{1,2}} &amp; ... &amp; &nbsp;\frac{\partial z_1}{\partial w_{C,F-1}}&amp; \frac{\partial z_1}{\partial w_{C,F}}&nbsp;\\ <br />\frac{\partial z_2}{\partial w_{1,1}} &amp; \frac{\partial z_2}{\partial w_{1,2}} &amp; ... &amp; &nbsp;\frac{\partial z_2}{\partial w_{C,F-1}}&amp; \frac{\partial z_2}{\partial w_{C,F}}&nbsp;\\<br />... &amp; ... &amp; ... &amp; &nbsp;... &amp; ... \\<br />\frac{\partial z_C}{\partial w_{1,1}} &amp; \frac{\partial z_C}{\partial w_{1,2}} &amp; ... &amp; &nbsp;\frac{\partial z_C}{\partial w_{C,F-1}}&amp; \frac{\partial z_C}{\partial w_{C,F}} \end{array} &nbsp;\right] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\tag{4}$<br /><br />From matrix multiplication (dot product of two vectors) we know that<br />$z_t = w_{t,1} x_1&nbsp;+ w_{t,2} x_2&nbsp;+ w_{t,3} x_3&nbsp;+ ...&nbsp;+ w_{t, F} x_F$<br />Therefore, we have $\frac{\partial z_t}{\partial w_{i,j}} = 0, ..., x1, x2, x3, ..., x_F, 0, ..., 0$<br />The partial derivatives are '0' when $i \neq t$<br /><br />Hence equation (4) is much simpler than its original form:<br />$ \frac{\partial Z}{\partial w_{i,j}} = \left[ &nbsp;\begin{array}{cccccccc} x_1 &amp; x_2 &amp; ... &amp; &nbsp;x_F &amp; 0 &nbsp;&amp; ... &amp; 0 &amp; 0 \\ &nbsp;0 &amp; ... &amp; x_1 &amp; &nbsp;... &amp; x_F &amp; 0 &amp; ... &amp; 0 \\ ... &amp; ... &amp; ... &amp; &nbsp;... &amp; ... &amp; ... &amp;... &amp;...\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; x_1 &amp; ... &amp; x_F \end{array} &nbsp;\right] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \tag{5}$<br />It is a sparse matrix, entries $\frac{\partial z_t}{\partial w_{i,j}}$ are mostly '0' except when row number equals row subscribe of W: $t == i$ and value at {t, (t-1)*F + j} is $x_j$.<br /><br />Put all 3 steps together, we will calculate the partial derivatives with regarding to W. Using chain rule, we need to calculate $\frac{\partial L}{\partial w_{i,j}} = \sum\limits_{k=1}^{c} \frac{\partial L}{\partial z_{k}} \frac{\partial z_{k}}{\partial w_{i,j}}$, which is just the dot product of vector (3) and column $(i-1)*C+j$ of matrix (4). Hence the partial derivatives can be calculated as vector (3) multiply matrix (4):<br /><br />$ \frac{\partial L}{\partial W} = \left[ &nbsp;\begin{array}{ccccc} \frac{\partial L}{\partial w_{1,1}}, &amp; \frac{\partial L}{\partial w_{1,2}}, &amp; ... ,&amp; &nbsp;\frac{\partial L}{\partial w_{C,F-1}},&amp; \frac{\partial L}{\partial w_{C,F}} &nbsp;\end{array} &nbsp;\right] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \tag{6}$<br /><br />Remember this row vector is just for convenience purpose. We can always rewrite the partial derivatives in matrix form:<br />$ \frac{\partial L}{\partial w_{i,j}} = \left[ &nbsp;\begin{array}{ccccc} \frac{\partial L}{\partial w_{1,1}} &amp; \frac{\partial L}{\partial w_{1,2}} &amp; ... &amp; &nbsp;\frac{\partial L}{\partial w_{1,F-1}} &amp; \frac{\partial L}{\partial w_{1,F}}\\<br />\frac{\partial L}{\partial w_{2,1}} &amp; \frac{\partial L}{\partial w_{2,2}} &amp; ... &amp; &nbsp; \frac{\partial L}{\partial w_{2,F-1}}&amp; \frac{\partial L}{\partial w_{2,F}} \\<br />... &amp; ... &amp; ... &amp; ... &nbsp;\\<br />&nbsp;\frac{\partial L}{\partial w_{C,1}} &amp; \frac{\partial L}{\partial w_{C,2}} &amp; ... &amp; &nbsp; \frac{\partial L}{\partial w_{C,F-1}}&amp; \frac{\partial L}{\partial w_{C,F}}&nbsp;&nbsp;\end{array} &nbsp;\right] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \tag{7}$<br /><br />Now let's check each element, like the one at {i,j}:<br /><br />$\frac{\partial L}{\partial w_{i,j}} = \sum\limits_{k=1}^{C}\frac{\partial L}{\partial z_k} \frac{\partial z_k}{\partial w_{i,j}} &nbsp; &nbsp; \tag{8}$<br /><br />From equation (5) we know that only when $k==i$, $\frac{\partial z_k}{\partial w_{i,j}}$ is not zero and the value is $x_j$. Using this property, together with equation (2), equation (8) can be simplified as:<br />$\frac{\partial L}{\partial w_{i,j}} = (q(z_i) - 1(y,i)) * x_j &nbsp; &nbsp; \tag{9}$<br /><br />Surprisingly, the final result is so simple and elegant. On the other hand, exponential function is the usual choice of eigenfunction for linear, time-invariant (LTI) systems. For more complicated systems, the result may not be as simple as Softmax, the onion peeling method should equally apply!</div></div>
